// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'teams_value_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$TeamsValueFailuresTearOff {
  const _$TeamsValueFailuresTearOff();

  InvalidTeamName<T> invalidTeamName<T>({required String? failedTeamValue}) {
    return InvalidTeamName<T>(
      failedTeamValue: failedTeamValue,
    );
  }

  InvalidTeamImage<T> invalidTeamImage<T>({required String? failedTeamValue}) {
    return InvalidTeamImage<T>(
      failedTeamValue: failedTeamValue,
    );
  }

  InvalidTeamMembers<T> invalidTeamMembers<T>(
      {required List<String>? failedTeamValue}) {
    return InvalidTeamMembers<T>(
      failedTeamValue: failedTeamValue,
    );
  }

  InvalidTeamMatches<T> invalidTeamMatches<T>(
      {required List<String>? failedTeamValue}) {
    return InvalidTeamMatches<T>(
      failedTeamValue: failedTeamValue,
    );
  }

  InvalidTeamLeagues<T> invalidTeamLeagues<T>(
      {required List<String>? failedTeamValue}) {
    return InvalidTeamLeagues<T>(
      failedTeamValue: failedTeamValue,
    );
  }

  InvalidTeamPubs<T> invalidTeamPubs<T>(
      {required List<String>? failedTeamValue}) {
    return InvalidTeamPubs<T>(
      failedTeamValue: failedTeamValue,
    );
  }
}

/// @nodoc
const $TeamsValueFailures = _$TeamsValueFailuresTearOff();

/// @nodoc
mixin _$TeamsValueFailures<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedTeamValue) invalidTeamName,
    required TResult Function(String? failedTeamValue) invalidTeamImage,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMembers,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMatches,
    required TResult Function(List<String>? failedTeamValue) invalidTeamLeagues,
    required TResult Function(List<String>? failedTeamValue) invalidTeamPubs,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidTeamName<T> value) invalidTeamName,
    required TResult Function(InvalidTeamImage<T> value) invalidTeamImage,
    required TResult Function(InvalidTeamMembers<T> value) invalidTeamMembers,
    required TResult Function(InvalidTeamMatches<T> value) invalidTeamMatches,
    required TResult Function(InvalidTeamLeagues<T> value) invalidTeamLeagues,
    required TResult Function(InvalidTeamPubs<T> value) invalidTeamPubs,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TeamsValueFailuresCopyWith<T, $Res> {
  factory $TeamsValueFailuresCopyWith(TeamsValueFailures<T> value,
          $Res Function(TeamsValueFailures<T>) then) =
      _$TeamsValueFailuresCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$TeamsValueFailuresCopyWithImpl<T, $Res>
    implements $TeamsValueFailuresCopyWith<T, $Res> {
  _$TeamsValueFailuresCopyWithImpl(this._value, this._then);

  final TeamsValueFailures<T> _value;
  // ignore: unused_field
  final $Res Function(TeamsValueFailures<T>) _then;
}

/// @nodoc
abstract class $InvalidTeamNameCopyWith<T, $Res> {
  factory $InvalidTeamNameCopyWith(
          InvalidTeamName<T> value, $Res Function(InvalidTeamName<T>) then) =
      _$InvalidTeamNameCopyWithImpl<T, $Res>;
  $Res call({String? failedTeamValue});
}

/// @nodoc
class _$InvalidTeamNameCopyWithImpl<T, $Res>
    extends _$TeamsValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidTeamNameCopyWith<T, $Res> {
  _$InvalidTeamNameCopyWithImpl(
      InvalidTeamName<T> _value, $Res Function(InvalidTeamName<T>) _then)
      : super(_value, (v) => _then(v as InvalidTeamName<T>));

  @override
  InvalidTeamName<T> get _value => super._value as InvalidTeamName<T>;

  @override
  $Res call({
    Object? failedTeamValue = freezed,
  }) {
    return _then(InvalidTeamName<T>(
      failedTeamValue: failedTeamValue == freezed
          ? _value.failedTeamValue
          : failedTeamValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidTeamName<T> implements InvalidTeamName<T> {
  const _$InvalidTeamName({required this.failedTeamValue});

  @override
  final String? failedTeamValue;

  @override
  String toString() {
    return 'TeamsValueFailures<$T>.invalidTeamName(failedTeamValue: $failedTeamValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidTeamName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedTeamValue, failedTeamValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedTeamValue));

  @JsonKey(ignore: true)
  @override
  $InvalidTeamNameCopyWith<T, InvalidTeamName<T>> get copyWith =>
      _$InvalidTeamNameCopyWithImpl<T, InvalidTeamName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedTeamValue) invalidTeamName,
    required TResult Function(String? failedTeamValue) invalidTeamImage,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMembers,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMatches,
    required TResult Function(List<String>? failedTeamValue) invalidTeamLeagues,
    required TResult Function(List<String>? failedTeamValue) invalidTeamPubs,
  }) {
    return invalidTeamName(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
  }) {
    return invalidTeamName?.call(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamName != null) {
      return invalidTeamName(failedTeamValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidTeamName<T> value) invalidTeamName,
    required TResult Function(InvalidTeamImage<T> value) invalidTeamImage,
    required TResult Function(InvalidTeamMembers<T> value) invalidTeamMembers,
    required TResult Function(InvalidTeamMatches<T> value) invalidTeamMatches,
    required TResult Function(InvalidTeamLeagues<T> value) invalidTeamLeagues,
    required TResult Function(InvalidTeamPubs<T> value) invalidTeamPubs,
  }) {
    return invalidTeamName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
  }) {
    return invalidTeamName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamName != null) {
      return invalidTeamName(this);
    }
    return orElse();
  }
}

abstract class InvalidTeamName<T> implements TeamsValueFailures<T> {
  const factory InvalidTeamName({required String? failedTeamValue}) =
      _$InvalidTeamName<T>;

  String? get failedTeamValue;
  @JsonKey(ignore: true)
  $InvalidTeamNameCopyWith<T, InvalidTeamName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidTeamImageCopyWith<T, $Res> {
  factory $InvalidTeamImageCopyWith(
          InvalidTeamImage<T> value, $Res Function(InvalidTeamImage<T>) then) =
      _$InvalidTeamImageCopyWithImpl<T, $Res>;
  $Res call({String? failedTeamValue});
}

/// @nodoc
class _$InvalidTeamImageCopyWithImpl<T, $Res>
    extends _$TeamsValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidTeamImageCopyWith<T, $Res> {
  _$InvalidTeamImageCopyWithImpl(
      InvalidTeamImage<T> _value, $Res Function(InvalidTeamImage<T>) _then)
      : super(_value, (v) => _then(v as InvalidTeamImage<T>));

  @override
  InvalidTeamImage<T> get _value => super._value as InvalidTeamImage<T>;

  @override
  $Res call({
    Object? failedTeamValue = freezed,
  }) {
    return _then(InvalidTeamImage<T>(
      failedTeamValue: failedTeamValue == freezed
          ? _value.failedTeamValue
          : failedTeamValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidTeamImage<T> implements InvalidTeamImage<T> {
  const _$InvalidTeamImage({required this.failedTeamValue});

  @override
  final String? failedTeamValue;

  @override
  String toString() {
    return 'TeamsValueFailures<$T>.invalidTeamImage(failedTeamValue: $failedTeamValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidTeamImage<T> &&
            const DeepCollectionEquality()
                .equals(other.failedTeamValue, failedTeamValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedTeamValue));

  @JsonKey(ignore: true)
  @override
  $InvalidTeamImageCopyWith<T, InvalidTeamImage<T>> get copyWith =>
      _$InvalidTeamImageCopyWithImpl<T, InvalidTeamImage<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedTeamValue) invalidTeamName,
    required TResult Function(String? failedTeamValue) invalidTeamImage,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMembers,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMatches,
    required TResult Function(List<String>? failedTeamValue) invalidTeamLeagues,
    required TResult Function(List<String>? failedTeamValue) invalidTeamPubs,
  }) {
    return invalidTeamImage(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
  }) {
    return invalidTeamImage?.call(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamImage != null) {
      return invalidTeamImage(failedTeamValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidTeamName<T> value) invalidTeamName,
    required TResult Function(InvalidTeamImage<T> value) invalidTeamImage,
    required TResult Function(InvalidTeamMembers<T> value) invalidTeamMembers,
    required TResult Function(InvalidTeamMatches<T> value) invalidTeamMatches,
    required TResult Function(InvalidTeamLeagues<T> value) invalidTeamLeagues,
    required TResult Function(InvalidTeamPubs<T> value) invalidTeamPubs,
  }) {
    return invalidTeamImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
  }) {
    return invalidTeamImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamImage != null) {
      return invalidTeamImage(this);
    }
    return orElse();
  }
}

abstract class InvalidTeamImage<T> implements TeamsValueFailures<T> {
  const factory InvalidTeamImage({required String? failedTeamValue}) =
      _$InvalidTeamImage<T>;

  String? get failedTeamValue;
  @JsonKey(ignore: true)
  $InvalidTeamImageCopyWith<T, InvalidTeamImage<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidTeamMembersCopyWith<T, $Res> {
  factory $InvalidTeamMembersCopyWith(InvalidTeamMembers<T> value,
          $Res Function(InvalidTeamMembers<T>) then) =
      _$InvalidTeamMembersCopyWithImpl<T, $Res>;
  $Res call({List<String>? failedTeamValue});
}

/// @nodoc
class _$InvalidTeamMembersCopyWithImpl<T, $Res>
    extends _$TeamsValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidTeamMembersCopyWith<T, $Res> {
  _$InvalidTeamMembersCopyWithImpl(
      InvalidTeamMembers<T> _value, $Res Function(InvalidTeamMembers<T>) _then)
      : super(_value, (v) => _then(v as InvalidTeamMembers<T>));

  @override
  InvalidTeamMembers<T> get _value => super._value as InvalidTeamMembers<T>;

  @override
  $Res call({
    Object? failedTeamValue = freezed,
  }) {
    return _then(InvalidTeamMembers<T>(
      failedTeamValue: failedTeamValue == freezed
          ? _value.failedTeamValue
          : failedTeamValue // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc

class _$InvalidTeamMembers<T> implements InvalidTeamMembers<T> {
  const _$InvalidTeamMembers({required this.failedTeamValue});

  @override
  final List<String>? failedTeamValue;

  @override
  String toString() {
    return 'TeamsValueFailures<$T>.invalidTeamMembers(failedTeamValue: $failedTeamValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidTeamMembers<T> &&
            const DeepCollectionEquality()
                .equals(other.failedTeamValue, failedTeamValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedTeamValue));

  @JsonKey(ignore: true)
  @override
  $InvalidTeamMembersCopyWith<T, InvalidTeamMembers<T>> get copyWith =>
      _$InvalidTeamMembersCopyWithImpl<T, InvalidTeamMembers<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedTeamValue) invalidTeamName,
    required TResult Function(String? failedTeamValue) invalidTeamImage,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMembers,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMatches,
    required TResult Function(List<String>? failedTeamValue) invalidTeamLeagues,
    required TResult Function(List<String>? failedTeamValue) invalidTeamPubs,
  }) {
    return invalidTeamMembers(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
  }) {
    return invalidTeamMembers?.call(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamMembers != null) {
      return invalidTeamMembers(failedTeamValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidTeamName<T> value) invalidTeamName,
    required TResult Function(InvalidTeamImage<T> value) invalidTeamImage,
    required TResult Function(InvalidTeamMembers<T> value) invalidTeamMembers,
    required TResult Function(InvalidTeamMatches<T> value) invalidTeamMatches,
    required TResult Function(InvalidTeamLeagues<T> value) invalidTeamLeagues,
    required TResult Function(InvalidTeamPubs<T> value) invalidTeamPubs,
  }) {
    return invalidTeamMembers(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
  }) {
    return invalidTeamMembers?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamMembers != null) {
      return invalidTeamMembers(this);
    }
    return orElse();
  }
}

abstract class InvalidTeamMembers<T> implements TeamsValueFailures<T> {
  const factory InvalidTeamMembers({required List<String>? failedTeamValue}) =
      _$InvalidTeamMembers<T>;

  List<String>? get failedTeamValue;
  @JsonKey(ignore: true)
  $InvalidTeamMembersCopyWith<T, InvalidTeamMembers<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidTeamMatchesCopyWith<T, $Res> {
  factory $InvalidTeamMatchesCopyWith(InvalidTeamMatches<T> value,
          $Res Function(InvalidTeamMatches<T>) then) =
      _$InvalidTeamMatchesCopyWithImpl<T, $Res>;
  $Res call({List<String>? failedTeamValue});
}

/// @nodoc
class _$InvalidTeamMatchesCopyWithImpl<T, $Res>
    extends _$TeamsValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidTeamMatchesCopyWith<T, $Res> {
  _$InvalidTeamMatchesCopyWithImpl(
      InvalidTeamMatches<T> _value, $Res Function(InvalidTeamMatches<T>) _then)
      : super(_value, (v) => _then(v as InvalidTeamMatches<T>));

  @override
  InvalidTeamMatches<T> get _value => super._value as InvalidTeamMatches<T>;

  @override
  $Res call({
    Object? failedTeamValue = freezed,
  }) {
    return _then(InvalidTeamMatches<T>(
      failedTeamValue: failedTeamValue == freezed
          ? _value.failedTeamValue
          : failedTeamValue // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc

class _$InvalidTeamMatches<T> implements InvalidTeamMatches<T> {
  const _$InvalidTeamMatches({required this.failedTeamValue});

  @override
  final List<String>? failedTeamValue;

  @override
  String toString() {
    return 'TeamsValueFailures<$T>.invalidTeamMatches(failedTeamValue: $failedTeamValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidTeamMatches<T> &&
            const DeepCollectionEquality()
                .equals(other.failedTeamValue, failedTeamValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedTeamValue));

  @JsonKey(ignore: true)
  @override
  $InvalidTeamMatchesCopyWith<T, InvalidTeamMatches<T>> get copyWith =>
      _$InvalidTeamMatchesCopyWithImpl<T, InvalidTeamMatches<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedTeamValue) invalidTeamName,
    required TResult Function(String? failedTeamValue) invalidTeamImage,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMembers,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMatches,
    required TResult Function(List<String>? failedTeamValue) invalidTeamLeagues,
    required TResult Function(List<String>? failedTeamValue) invalidTeamPubs,
  }) {
    return invalidTeamMatches(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
  }) {
    return invalidTeamMatches?.call(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamMatches != null) {
      return invalidTeamMatches(failedTeamValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidTeamName<T> value) invalidTeamName,
    required TResult Function(InvalidTeamImage<T> value) invalidTeamImage,
    required TResult Function(InvalidTeamMembers<T> value) invalidTeamMembers,
    required TResult Function(InvalidTeamMatches<T> value) invalidTeamMatches,
    required TResult Function(InvalidTeamLeagues<T> value) invalidTeamLeagues,
    required TResult Function(InvalidTeamPubs<T> value) invalidTeamPubs,
  }) {
    return invalidTeamMatches(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
  }) {
    return invalidTeamMatches?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamMatches != null) {
      return invalidTeamMatches(this);
    }
    return orElse();
  }
}

abstract class InvalidTeamMatches<T> implements TeamsValueFailures<T> {
  const factory InvalidTeamMatches({required List<String>? failedTeamValue}) =
      _$InvalidTeamMatches<T>;

  List<String>? get failedTeamValue;
  @JsonKey(ignore: true)
  $InvalidTeamMatchesCopyWith<T, InvalidTeamMatches<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidTeamLeaguesCopyWith<T, $Res> {
  factory $InvalidTeamLeaguesCopyWith(InvalidTeamLeagues<T> value,
          $Res Function(InvalidTeamLeagues<T>) then) =
      _$InvalidTeamLeaguesCopyWithImpl<T, $Res>;
  $Res call({List<String>? failedTeamValue});
}

/// @nodoc
class _$InvalidTeamLeaguesCopyWithImpl<T, $Res>
    extends _$TeamsValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidTeamLeaguesCopyWith<T, $Res> {
  _$InvalidTeamLeaguesCopyWithImpl(
      InvalidTeamLeagues<T> _value, $Res Function(InvalidTeamLeagues<T>) _then)
      : super(_value, (v) => _then(v as InvalidTeamLeagues<T>));

  @override
  InvalidTeamLeagues<T> get _value => super._value as InvalidTeamLeagues<T>;

  @override
  $Res call({
    Object? failedTeamValue = freezed,
  }) {
    return _then(InvalidTeamLeagues<T>(
      failedTeamValue: failedTeamValue == freezed
          ? _value.failedTeamValue
          : failedTeamValue // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc

class _$InvalidTeamLeagues<T> implements InvalidTeamLeagues<T> {
  const _$InvalidTeamLeagues({required this.failedTeamValue});

  @override
  final List<String>? failedTeamValue;

  @override
  String toString() {
    return 'TeamsValueFailures<$T>.invalidTeamLeagues(failedTeamValue: $failedTeamValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidTeamLeagues<T> &&
            const DeepCollectionEquality()
                .equals(other.failedTeamValue, failedTeamValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedTeamValue));

  @JsonKey(ignore: true)
  @override
  $InvalidTeamLeaguesCopyWith<T, InvalidTeamLeagues<T>> get copyWith =>
      _$InvalidTeamLeaguesCopyWithImpl<T, InvalidTeamLeagues<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedTeamValue) invalidTeamName,
    required TResult Function(String? failedTeamValue) invalidTeamImage,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMembers,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMatches,
    required TResult Function(List<String>? failedTeamValue) invalidTeamLeagues,
    required TResult Function(List<String>? failedTeamValue) invalidTeamPubs,
  }) {
    return invalidTeamLeagues(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
  }) {
    return invalidTeamLeagues?.call(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamLeagues != null) {
      return invalidTeamLeagues(failedTeamValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidTeamName<T> value) invalidTeamName,
    required TResult Function(InvalidTeamImage<T> value) invalidTeamImage,
    required TResult Function(InvalidTeamMembers<T> value) invalidTeamMembers,
    required TResult Function(InvalidTeamMatches<T> value) invalidTeamMatches,
    required TResult Function(InvalidTeamLeagues<T> value) invalidTeamLeagues,
    required TResult Function(InvalidTeamPubs<T> value) invalidTeamPubs,
  }) {
    return invalidTeamLeagues(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
  }) {
    return invalidTeamLeagues?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamLeagues != null) {
      return invalidTeamLeagues(this);
    }
    return orElse();
  }
}

abstract class InvalidTeamLeagues<T> implements TeamsValueFailures<T> {
  const factory InvalidTeamLeagues({required List<String>? failedTeamValue}) =
      _$InvalidTeamLeagues<T>;

  List<String>? get failedTeamValue;
  @JsonKey(ignore: true)
  $InvalidTeamLeaguesCopyWith<T, InvalidTeamLeagues<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidTeamPubsCopyWith<T, $Res> {
  factory $InvalidTeamPubsCopyWith(
          InvalidTeamPubs<T> value, $Res Function(InvalidTeamPubs<T>) then) =
      _$InvalidTeamPubsCopyWithImpl<T, $Res>;
  $Res call({List<String>? failedTeamValue});
}

/// @nodoc
class _$InvalidTeamPubsCopyWithImpl<T, $Res>
    extends _$TeamsValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidTeamPubsCopyWith<T, $Res> {
  _$InvalidTeamPubsCopyWithImpl(
      InvalidTeamPubs<T> _value, $Res Function(InvalidTeamPubs<T>) _then)
      : super(_value, (v) => _then(v as InvalidTeamPubs<T>));

  @override
  InvalidTeamPubs<T> get _value => super._value as InvalidTeamPubs<T>;

  @override
  $Res call({
    Object? failedTeamValue = freezed,
  }) {
    return _then(InvalidTeamPubs<T>(
      failedTeamValue: failedTeamValue == freezed
          ? _value.failedTeamValue
          : failedTeamValue // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc

class _$InvalidTeamPubs<T> implements InvalidTeamPubs<T> {
  const _$InvalidTeamPubs({required this.failedTeamValue});

  @override
  final List<String>? failedTeamValue;

  @override
  String toString() {
    return 'TeamsValueFailures<$T>.invalidTeamPubs(failedTeamValue: $failedTeamValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidTeamPubs<T> &&
            const DeepCollectionEquality()
                .equals(other.failedTeamValue, failedTeamValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedTeamValue));

  @JsonKey(ignore: true)
  @override
  $InvalidTeamPubsCopyWith<T, InvalidTeamPubs<T>> get copyWith =>
      _$InvalidTeamPubsCopyWithImpl<T, InvalidTeamPubs<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedTeamValue) invalidTeamName,
    required TResult Function(String? failedTeamValue) invalidTeamImage,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMembers,
    required TResult Function(List<String>? failedTeamValue) invalidTeamMatches,
    required TResult Function(List<String>? failedTeamValue) invalidTeamLeagues,
    required TResult Function(List<String>? failedTeamValue) invalidTeamPubs,
  }) {
    return invalidTeamPubs(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
  }) {
    return invalidTeamPubs?.call(failedTeamValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedTeamValue)? invalidTeamName,
    TResult Function(String? failedTeamValue)? invalidTeamImage,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMembers,
    TResult Function(List<String>? failedTeamValue)? invalidTeamMatches,
    TResult Function(List<String>? failedTeamValue)? invalidTeamLeagues,
    TResult Function(List<String>? failedTeamValue)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamPubs != null) {
      return invalidTeamPubs(failedTeamValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidTeamName<T> value) invalidTeamName,
    required TResult Function(InvalidTeamImage<T> value) invalidTeamImage,
    required TResult Function(InvalidTeamMembers<T> value) invalidTeamMembers,
    required TResult Function(InvalidTeamMatches<T> value) invalidTeamMatches,
    required TResult Function(InvalidTeamLeagues<T> value) invalidTeamLeagues,
    required TResult Function(InvalidTeamPubs<T> value) invalidTeamPubs,
  }) {
    return invalidTeamPubs(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
  }) {
    return invalidTeamPubs?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidTeamName<T> value)? invalidTeamName,
    TResult Function(InvalidTeamImage<T> value)? invalidTeamImage,
    TResult Function(InvalidTeamMembers<T> value)? invalidTeamMembers,
    TResult Function(InvalidTeamMatches<T> value)? invalidTeamMatches,
    TResult Function(InvalidTeamLeagues<T> value)? invalidTeamLeagues,
    TResult Function(InvalidTeamPubs<T> value)? invalidTeamPubs,
    required TResult orElse(),
  }) {
    if (invalidTeamPubs != null) {
      return invalidTeamPubs(this);
    }
    return orElse();
  }
}

abstract class InvalidTeamPubs<T> implements TeamsValueFailures<T> {
  const factory InvalidTeamPubs({required List<String>? failedTeamValue}) =
      _$InvalidTeamPubs<T>;

  List<String>? get failedTeamValue;
  @JsonKey(ignore: true)
  $InvalidTeamPubsCopyWith<T, InvalidTeamPubs<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
