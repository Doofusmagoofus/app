// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'matches_value_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$MatchValueFailuresTearOff {
  const _$MatchValueFailuresTearOff();

  InvalidMatchName<T> invalidMatchName<T>({required String? failedMatchValue}) {
    return InvalidMatchName<T>(
      failedMatchValue: failedMatchValue,
    );
  }

  InvalidMatchStatusType<T> invalidMatchStatus<T>(
      {required String? failedMatchValue}) {
    return InvalidMatchStatusType<T>(
      failedMatchValue: failedMatchValue,
    );
  }

  InvalidMatchDateTime<T> invalidMatchDateTime<T>(
      {required String? failedMatchValue}) {
    return InvalidMatchDateTime<T>(
      failedMatchValue: failedMatchValue,
    );
  }

  InvalidMatchType<T> invalidMatchType<T>({required String? failedMatchValue}) {
    return InvalidMatchType<T>(
      failedMatchValue: failedMatchValue,
    );
  }

  InvalidMatchTeams<T> invalidMatchTeams<T>(
      {required List<String>? failedMatchValue}) {
    return InvalidMatchTeams<T>(
      failedMatchValue: failedMatchValue,
    );
  }

  InvalidMatchResult<T> invalidMatchResult<T>(
      {required String? failedMatchValue}) {
    return InvalidMatchResult<T>(
      failedMatchValue: failedMatchValue,
    );
  }
}

/// @nodoc
const $MatchValueFailures = _$MatchValueFailuresTearOff();

/// @nodoc
mixin _$MatchValueFailures<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedMatchValue) invalidMatchName,
    required TResult Function(String? failedMatchValue) invalidMatchStatus,
    required TResult Function(String? failedMatchValue) invalidMatchDateTime,
    required TResult Function(String? failedMatchValue) invalidMatchType,
    required TResult Function(List<String>? failedMatchValue) invalidMatchTeams,
    required TResult Function(String? failedMatchValue) invalidMatchResult,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidMatchName<T> value) invalidMatchName,
    required TResult Function(InvalidMatchStatusType<T> value)
        invalidMatchStatus,
    required TResult Function(InvalidMatchDateTime<T> value)
        invalidMatchDateTime,
    required TResult Function(InvalidMatchType<T> value) invalidMatchType,
    required TResult Function(InvalidMatchTeams<T> value) invalidMatchTeams,
    required TResult Function(InvalidMatchResult<T> value) invalidMatchResult,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MatchValueFailuresCopyWith<T, $Res> {
  factory $MatchValueFailuresCopyWith(MatchValueFailures<T> value,
          $Res Function(MatchValueFailures<T>) then) =
      _$MatchValueFailuresCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$MatchValueFailuresCopyWithImpl<T, $Res>
    implements $MatchValueFailuresCopyWith<T, $Res> {
  _$MatchValueFailuresCopyWithImpl(this._value, this._then);

  final MatchValueFailures<T> _value;
  // ignore: unused_field
  final $Res Function(MatchValueFailures<T>) _then;
}

/// @nodoc
abstract class $InvalidMatchNameCopyWith<T, $Res> {
  factory $InvalidMatchNameCopyWith(
          InvalidMatchName<T> value, $Res Function(InvalidMatchName<T>) then) =
      _$InvalidMatchNameCopyWithImpl<T, $Res>;
  $Res call({String? failedMatchValue});
}

/// @nodoc
class _$InvalidMatchNameCopyWithImpl<T, $Res>
    extends _$MatchValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidMatchNameCopyWith<T, $Res> {
  _$InvalidMatchNameCopyWithImpl(
      InvalidMatchName<T> _value, $Res Function(InvalidMatchName<T>) _then)
      : super(_value, (v) => _then(v as InvalidMatchName<T>));

  @override
  InvalidMatchName<T> get _value => super._value as InvalidMatchName<T>;

  @override
  $Res call({
    Object? failedMatchValue = freezed,
  }) {
    return _then(InvalidMatchName<T>(
      failedMatchValue: failedMatchValue == freezed
          ? _value.failedMatchValue
          : failedMatchValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidMatchName<T> implements InvalidMatchName<T> {
  const _$InvalidMatchName({required this.failedMatchValue});

  @override
  final String? failedMatchValue;

  @override
  String toString() {
    return 'MatchValueFailures<$T>.invalidMatchName(failedMatchValue: $failedMatchValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidMatchName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedMatchValue, failedMatchValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedMatchValue));

  @JsonKey(ignore: true)
  @override
  $InvalidMatchNameCopyWith<T, InvalidMatchName<T>> get copyWith =>
      _$InvalidMatchNameCopyWithImpl<T, InvalidMatchName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedMatchValue) invalidMatchName,
    required TResult Function(String? failedMatchValue) invalidMatchStatus,
    required TResult Function(String? failedMatchValue) invalidMatchDateTime,
    required TResult Function(String? failedMatchValue) invalidMatchType,
    required TResult Function(List<String>? failedMatchValue) invalidMatchTeams,
    required TResult Function(String? failedMatchValue) invalidMatchResult,
  }) {
    return invalidMatchName(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
  }) {
    return invalidMatchName?.call(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchName != null) {
      return invalidMatchName(failedMatchValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidMatchName<T> value) invalidMatchName,
    required TResult Function(InvalidMatchStatusType<T> value)
        invalidMatchStatus,
    required TResult Function(InvalidMatchDateTime<T> value)
        invalidMatchDateTime,
    required TResult Function(InvalidMatchType<T> value) invalidMatchType,
    required TResult Function(InvalidMatchTeams<T> value) invalidMatchTeams,
    required TResult Function(InvalidMatchResult<T> value) invalidMatchResult,
  }) {
    return invalidMatchName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
  }) {
    return invalidMatchName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchName != null) {
      return invalidMatchName(this);
    }
    return orElse();
  }
}

abstract class InvalidMatchName<T> implements MatchValueFailures<T> {
  const factory InvalidMatchName({required String? failedMatchValue}) =
      _$InvalidMatchName<T>;

  String? get failedMatchValue;
  @JsonKey(ignore: true)
  $InvalidMatchNameCopyWith<T, InvalidMatchName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidMatchStatusTypeCopyWith<T, $Res> {
  factory $InvalidMatchStatusTypeCopyWith(InvalidMatchStatusType<T> value,
          $Res Function(InvalidMatchStatusType<T>) then) =
      _$InvalidMatchStatusTypeCopyWithImpl<T, $Res>;
  $Res call({String? failedMatchValue});
}

/// @nodoc
class _$InvalidMatchStatusTypeCopyWithImpl<T, $Res>
    extends _$MatchValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidMatchStatusTypeCopyWith<T, $Res> {
  _$InvalidMatchStatusTypeCopyWithImpl(InvalidMatchStatusType<T> _value,
      $Res Function(InvalidMatchStatusType<T>) _then)
      : super(_value, (v) => _then(v as InvalidMatchStatusType<T>));

  @override
  InvalidMatchStatusType<T> get _value =>
      super._value as InvalidMatchStatusType<T>;

  @override
  $Res call({
    Object? failedMatchValue = freezed,
  }) {
    return _then(InvalidMatchStatusType<T>(
      failedMatchValue: failedMatchValue == freezed
          ? _value.failedMatchValue
          : failedMatchValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidMatchStatusType<T> implements InvalidMatchStatusType<T> {
  const _$InvalidMatchStatusType({required this.failedMatchValue});

  @override
  final String? failedMatchValue;

  @override
  String toString() {
    return 'MatchValueFailures<$T>.invalidMatchStatus(failedMatchValue: $failedMatchValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidMatchStatusType<T> &&
            const DeepCollectionEquality()
                .equals(other.failedMatchValue, failedMatchValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedMatchValue));

  @JsonKey(ignore: true)
  @override
  $InvalidMatchStatusTypeCopyWith<T, InvalidMatchStatusType<T>> get copyWith =>
      _$InvalidMatchStatusTypeCopyWithImpl<T, InvalidMatchStatusType<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedMatchValue) invalidMatchName,
    required TResult Function(String? failedMatchValue) invalidMatchStatus,
    required TResult Function(String? failedMatchValue) invalidMatchDateTime,
    required TResult Function(String? failedMatchValue) invalidMatchType,
    required TResult Function(List<String>? failedMatchValue) invalidMatchTeams,
    required TResult Function(String? failedMatchValue) invalidMatchResult,
  }) {
    return invalidMatchStatus(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
  }) {
    return invalidMatchStatus?.call(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchStatus != null) {
      return invalidMatchStatus(failedMatchValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidMatchName<T> value) invalidMatchName,
    required TResult Function(InvalidMatchStatusType<T> value)
        invalidMatchStatus,
    required TResult Function(InvalidMatchDateTime<T> value)
        invalidMatchDateTime,
    required TResult Function(InvalidMatchType<T> value) invalidMatchType,
    required TResult Function(InvalidMatchTeams<T> value) invalidMatchTeams,
    required TResult Function(InvalidMatchResult<T> value) invalidMatchResult,
  }) {
    return invalidMatchStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
  }) {
    return invalidMatchStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchStatus != null) {
      return invalidMatchStatus(this);
    }
    return orElse();
  }
}

abstract class InvalidMatchStatusType<T> implements MatchValueFailures<T> {
  const factory InvalidMatchStatusType({required String? failedMatchValue}) =
      _$InvalidMatchStatusType<T>;

  String? get failedMatchValue;
  @JsonKey(ignore: true)
  $InvalidMatchStatusTypeCopyWith<T, InvalidMatchStatusType<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidMatchDateTimeCopyWith<T, $Res> {
  factory $InvalidMatchDateTimeCopyWith(InvalidMatchDateTime<T> value,
          $Res Function(InvalidMatchDateTime<T>) then) =
      _$InvalidMatchDateTimeCopyWithImpl<T, $Res>;
  $Res call({String? failedMatchValue});
}

/// @nodoc
class _$InvalidMatchDateTimeCopyWithImpl<T, $Res>
    extends _$MatchValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidMatchDateTimeCopyWith<T, $Res> {
  _$InvalidMatchDateTimeCopyWithImpl(InvalidMatchDateTime<T> _value,
      $Res Function(InvalidMatchDateTime<T>) _then)
      : super(_value, (v) => _then(v as InvalidMatchDateTime<T>));

  @override
  InvalidMatchDateTime<T> get _value => super._value as InvalidMatchDateTime<T>;

  @override
  $Res call({
    Object? failedMatchValue = freezed,
  }) {
    return _then(InvalidMatchDateTime<T>(
      failedMatchValue: failedMatchValue == freezed
          ? _value.failedMatchValue
          : failedMatchValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidMatchDateTime<T> implements InvalidMatchDateTime<T> {
  const _$InvalidMatchDateTime({required this.failedMatchValue});

  @override
  final String? failedMatchValue;

  @override
  String toString() {
    return 'MatchValueFailures<$T>.invalidMatchDateTime(failedMatchValue: $failedMatchValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidMatchDateTime<T> &&
            const DeepCollectionEquality()
                .equals(other.failedMatchValue, failedMatchValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedMatchValue));

  @JsonKey(ignore: true)
  @override
  $InvalidMatchDateTimeCopyWith<T, InvalidMatchDateTime<T>> get copyWith =>
      _$InvalidMatchDateTimeCopyWithImpl<T, InvalidMatchDateTime<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedMatchValue) invalidMatchName,
    required TResult Function(String? failedMatchValue) invalidMatchStatus,
    required TResult Function(String? failedMatchValue) invalidMatchDateTime,
    required TResult Function(String? failedMatchValue) invalidMatchType,
    required TResult Function(List<String>? failedMatchValue) invalidMatchTeams,
    required TResult Function(String? failedMatchValue) invalidMatchResult,
  }) {
    return invalidMatchDateTime(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
  }) {
    return invalidMatchDateTime?.call(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchDateTime != null) {
      return invalidMatchDateTime(failedMatchValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidMatchName<T> value) invalidMatchName,
    required TResult Function(InvalidMatchStatusType<T> value)
        invalidMatchStatus,
    required TResult Function(InvalidMatchDateTime<T> value)
        invalidMatchDateTime,
    required TResult Function(InvalidMatchType<T> value) invalidMatchType,
    required TResult Function(InvalidMatchTeams<T> value) invalidMatchTeams,
    required TResult Function(InvalidMatchResult<T> value) invalidMatchResult,
  }) {
    return invalidMatchDateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
  }) {
    return invalidMatchDateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchDateTime != null) {
      return invalidMatchDateTime(this);
    }
    return orElse();
  }
}

abstract class InvalidMatchDateTime<T> implements MatchValueFailures<T> {
  const factory InvalidMatchDateTime({required String? failedMatchValue}) =
      _$InvalidMatchDateTime<T>;

  String? get failedMatchValue;
  @JsonKey(ignore: true)
  $InvalidMatchDateTimeCopyWith<T, InvalidMatchDateTime<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidMatchTypeCopyWith<T, $Res> {
  factory $InvalidMatchTypeCopyWith(
          InvalidMatchType<T> value, $Res Function(InvalidMatchType<T>) then) =
      _$InvalidMatchTypeCopyWithImpl<T, $Res>;
  $Res call({String? failedMatchValue});
}

/// @nodoc
class _$InvalidMatchTypeCopyWithImpl<T, $Res>
    extends _$MatchValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidMatchTypeCopyWith<T, $Res> {
  _$InvalidMatchTypeCopyWithImpl(
      InvalidMatchType<T> _value, $Res Function(InvalidMatchType<T>) _then)
      : super(_value, (v) => _then(v as InvalidMatchType<T>));

  @override
  InvalidMatchType<T> get _value => super._value as InvalidMatchType<T>;

  @override
  $Res call({
    Object? failedMatchValue = freezed,
  }) {
    return _then(InvalidMatchType<T>(
      failedMatchValue: failedMatchValue == freezed
          ? _value.failedMatchValue
          : failedMatchValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidMatchType<T> implements InvalidMatchType<T> {
  const _$InvalidMatchType({required this.failedMatchValue});

  @override
  final String? failedMatchValue;

  @override
  String toString() {
    return 'MatchValueFailures<$T>.invalidMatchType(failedMatchValue: $failedMatchValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidMatchType<T> &&
            const DeepCollectionEquality()
                .equals(other.failedMatchValue, failedMatchValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedMatchValue));

  @JsonKey(ignore: true)
  @override
  $InvalidMatchTypeCopyWith<T, InvalidMatchType<T>> get copyWith =>
      _$InvalidMatchTypeCopyWithImpl<T, InvalidMatchType<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedMatchValue) invalidMatchName,
    required TResult Function(String? failedMatchValue) invalidMatchStatus,
    required TResult Function(String? failedMatchValue) invalidMatchDateTime,
    required TResult Function(String? failedMatchValue) invalidMatchType,
    required TResult Function(List<String>? failedMatchValue) invalidMatchTeams,
    required TResult Function(String? failedMatchValue) invalidMatchResult,
  }) {
    return invalidMatchType(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
  }) {
    return invalidMatchType?.call(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchType != null) {
      return invalidMatchType(failedMatchValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidMatchName<T> value) invalidMatchName,
    required TResult Function(InvalidMatchStatusType<T> value)
        invalidMatchStatus,
    required TResult Function(InvalidMatchDateTime<T> value)
        invalidMatchDateTime,
    required TResult Function(InvalidMatchType<T> value) invalidMatchType,
    required TResult Function(InvalidMatchTeams<T> value) invalidMatchTeams,
    required TResult Function(InvalidMatchResult<T> value) invalidMatchResult,
  }) {
    return invalidMatchType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
  }) {
    return invalidMatchType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchType != null) {
      return invalidMatchType(this);
    }
    return orElse();
  }
}

abstract class InvalidMatchType<T> implements MatchValueFailures<T> {
  const factory InvalidMatchType({required String? failedMatchValue}) =
      _$InvalidMatchType<T>;

  String? get failedMatchValue;
  @JsonKey(ignore: true)
  $InvalidMatchTypeCopyWith<T, InvalidMatchType<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidMatchTeamsCopyWith<T, $Res> {
  factory $InvalidMatchTeamsCopyWith(InvalidMatchTeams<T> value,
          $Res Function(InvalidMatchTeams<T>) then) =
      _$InvalidMatchTeamsCopyWithImpl<T, $Res>;
  $Res call({List<String>? failedMatchValue});
}

/// @nodoc
class _$InvalidMatchTeamsCopyWithImpl<T, $Res>
    extends _$MatchValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidMatchTeamsCopyWith<T, $Res> {
  _$InvalidMatchTeamsCopyWithImpl(
      InvalidMatchTeams<T> _value, $Res Function(InvalidMatchTeams<T>) _then)
      : super(_value, (v) => _then(v as InvalidMatchTeams<T>));

  @override
  InvalidMatchTeams<T> get _value => super._value as InvalidMatchTeams<T>;

  @override
  $Res call({
    Object? failedMatchValue = freezed,
  }) {
    return _then(InvalidMatchTeams<T>(
      failedMatchValue: failedMatchValue == freezed
          ? _value.failedMatchValue
          : failedMatchValue // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc

class _$InvalidMatchTeams<T> implements InvalidMatchTeams<T> {
  const _$InvalidMatchTeams({required this.failedMatchValue});

  @override
  final List<String>? failedMatchValue;

  @override
  String toString() {
    return 'MatchValueFailures<$T>.invalidMatchTeams(failedMatchValue: $failedMatchValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidMatchTeams<T> &&
            const DeepCollectionEquality()
                .equals(other.failedMatchValue, failedMatchValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedMatchValue));

  @JsonKey(ignore: true)
  @override
  $InvalidMatchTeamsCopyWith<T, InvalidMatchTeams<T>> get copyWith =>
      _$InvalidMatchTeamsCopyWithImpl<T, InvalidMatchTeams<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedMatchValue) invalidMatchName,
    required TResult Function(String? failedMatchValue) invalidMatchStatus,
    required TResult Function(String? failedMatchValue) invalidMatchDateTime,
    required TResult Function(String? failedMatchValue) invalidMatchType,
    required TResult Function(List<String>? failedMatchValue) invalidMatchTeams,
    required TResult Function(String? failedMatchValue) invalidMatchResult,
  }) {
    return invalidMatchTeams(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
  }) {
    return invalidMatchTeams?.call(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchTeams != null) {
      return invalidMatchTeams(failedMatchValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidMatchName<T> value) invalidMatchName,
    required TResult Function(InvalidMatchStatusType<T> value)
        invalidMatchStatus,
    required TResult Function(InvalidMatchDateTime<T> value)
        invalidMatchDateTime,
    required TResult Function(InvalidMatchType<T> value) invalidMatchType,
    required TResult Function(InvalidMatchTeams<T> value) invalidMatchTeams,
    required TResult Function(InvalidMatchResult<T> value) invalidMatchResult,
  }) {
    return invalidMatchTeams(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
  }) {
    return invalidMatchTeams?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchTeams != null) {
      return invalidMatchTeams(this);
    }
    return orElse();
  }
}

abstract class InvalidMatchTeams<T> implements MatchValueFailures<T> {
  const factory InvalidMatchTeams({required List<String>? failedMatchValue}) =
      _$InvalidMatchTeams<T>;

  List<String>? get failedMatchValue;
  @JsonKey(ignore: true)
  $InvalidMatchTeamsCopyWith<T, InvalidMatchTeams<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidMatchResultCopyWith<T, $Res> {
  factory $InvalidMatchResultCopyWith(InvalidMatchResult<T> value,
          $Res Function(InvalidMatchResult<T>) then) =
      _$InvalidMatchResultCopyWithImpl<T, $Res>;
  $Res call({String? failedMatchValue});
}

/// @nodoc
class _$InvalidMatchResultCopyWithImpl<T, $Res>
    extends _$MatchValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidMatchResultCopyWith<T, $Res> {
  _$InvalidMatchResultCopyWithImpl(
      InvalidMatchResult<T> _value, $Res Function(InvalidMatchResult<T>) _then)
      : super(_value, (v) => _then(v as InvalidMatchResult<T>));

  @override
  InvalidMatchResult<T> get _value => super._value as InvalidMatchResult<T>;

  @override
  $Res call({
    Object? failedMatchValue = freezed,
  }) {
    return _then(InvalidMatchResult<T>(
      failedMatchValue: failedMatchValue == freezed
          ? _value.failedMatchValue
          : failedMatchValue // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidMatchResult<T> implements InvalidMatchResult<T> {
  const _$InvalidMatchResult({required this.failedMatchValue});

  @override
  final String? failedMatchValue;

  @override
  String toString() {
    return 'MatchValueFailures<$T>.invalidMatchResult(failedMatchValue: $failedMatchValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidMatchResult<T> &&
            const DeepCollectionEquality()
                .equals(other.failedMatchValue, failedMatchValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedMatchValue));

  @JsonKey(ignore: true)
  @override
  $InvalidMatchResultCopyWith<T, InvalidMatchResult<T>> get copyWith =>
      _$InvalidMatchResultCopyWithImpl<T, InvalidMatchResult<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? failedMatchValue) invalidMatchName,
    required TResult Function(String? failedMatchValue) invalidMatchStatus,
    required TResult Function(String? failedMatchValue) invalidMatchDateTime,
    required TResult Function(String? failedMatchValue) invalidMatchType,
    required TResult Function(List<String>? failedMatchValue) invalidMatchTeams,
    required TResult Function(String? failedMatchValue) invalidMatchResult,
  }) {
    return invalidMatchResult(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
  }) {
    return invalidMatchResult?.call(failedMatchValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? failedMatchValue)? invalidMatchName,
    TResult Function(String? failedMatchValue)? invalidMatchStatus,
    TResult Function(String? failedMatchValue)? invalidMatchDateTime,
    TResult Function(String? failedMatchValue)? invalidMatchType,
    TResult Function(List<String>? failedMatchValue)? invalidMatchTeams,
    TResult Function(String? failedMatchValue)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchResult != null) {
      return invalidMatchResult(failedMatchValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidMatchName<T> value) invalidMatchName,
    required TResult Function(InvalidMatchStatusType<T> value)
        invalidMatchStatus,
    required TResult Function(InvalidMatchDateTime<T> value)
        invalidMatchDateTime,
    required TResult Function(InvalidMatchType<T> value) invalidMatchType,
    required TResult Function(InvalidMatchTeams<T> value) invalidMatchTeams,
    required TResult Function(InvalidMatchResult<T> value) invalidMatchResult,
  }) {
    return invalidMatchResult(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
  }) {
    return invalidMatchResult?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidMatchName<T> value)? invalidMatchName,
    TResult Function(InvalidMatchStatusType<T> value)? invalidMatchStatus,
    TResult Function(InvalidMatchDateTime<T> value)? invalidMatchDateTime,
    TResult Function(InvalidMatchType<T> value)? invalidMatchType,
    TResult Function(InvalidMatchTeams<T> value)? invalidMatchTeams,
    TResult Function(InvalidMatchResult<T> value)? invalidMatchResult,
    required TResult orElse(),
  }) {
    if (invalidMatchResult != null) {
      return invalidMatchResult(this);
    }
    return orElse();
  }
}

abstract class InvalidMatchResult<T> implements MatchValueFailures<T> {
  const factory InvalidMatchResult({required String? failedMatchValue}) =
      _$InvalidMatchResult<T>;

  String? get failedMatchValue;
  @JsonKey(ignore: true)
  $InvalidMatchResultCopyWith<T, InvalidMatchResult<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
